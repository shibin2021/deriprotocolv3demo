type DToken @entity {
  id: ID!
  name: String!
  ownerTokenId: [OwnerTokenId!]! @derivedFrom(field: "token")
}

type OwnerTokenId @entity {
  id: ID!
  owner: Bytes!
  tokenId: String!
  token: DToken!
  timestamp: Int!
}

type Vault @entity {
  id: ID!
  aavePool: Bytes!
  aaveOracle: Bytes!
}

type BToken @entity {
  id: ID!
  bToken: Bytes!
  bTokenSymbol: String!
  market: Bytes!
  marketSymbol: String!
  bTokenPrice: BigInt!
  collateralFactor: BigDecimal!
  pool: Pool!
}

type Symbol @entity {
  id: ID!
  category: String!
  symbol: String!
  symbolAddress: Bytes!
  manager: Bytes!
  oracleManager: Bytes!
  symbolId: Bytes!
  feeRatio: BigInt!
  alpha: BigInt!
  fundingPeriod: BigInt!
  minTradeVolume: BigInt!
  minInitialMarginRatio: BigInt!
  initialMarginRatio: BigInt!
  maintenanceMarginRatio: BigInt!
  pricePercentThreshold: BigInt!
  timeThreshold: BigInt!
  isCloseOnly: Boolean!
  priceId: Bytes!
  volatilityId: Bytes!
  feeRatioITM: BigInt!
  feeRatioOTM: BigInt!
  strikePrice: BigInt!
  isCall: Boolean!

  netVolume: BigInt!
  netCost: BigInt!
  indexPrice: BigInt!
  fundingTimestamp: BigInt!
  cumulativeFundingPerVolume: BigInt!
  tradersPnl: BigInt!
  initialMarginRequired: BigInt!
  nPositionHolders: BigInt!

  curIndexPrice: BigInt!
  curVolatility: BigInt!
  curCumulativeFundingPerVolume: BigInt!
  K: BigInt!
  markPrice: BigInt!
  funding: BigInt!
  timeValue: BigInt!
  delta: BigInt!
  u: BigInt!

  power: BigInt!
  hT: BigInt!
  powerPrice: BigInt!
  theoreticalPrice: BigInt!
}

type LiquidityHistory @entity {
  id: ID!
  pool: Pool!
  account: Bytes!
  bTokenAddress: Bytes!
  bToken: String!
  lTokenId: BigInt!
  amount: BigInt!
  newLiquidity: BigInt!
  timestamp: Int!
}

type Liquidity @entity {
  id: ID!
  pool: Pool!
  poolAccount: PoolAccount!
  # account: Bytes!
  bTokenAddress: Bytes!
  bToken: String!
  lTokenId: BigInt!
  liquidity: BigInt!
  timestamp: Int!
}


type MarginHistory @entity {
  id: ID!
  pool: Pool!
  account: Bytes!
  bTokenAddress: Bytes!
  bToken: String!
  pTokenId: BigInt!
  amount: BigInt!
  newMargin: BigInt!
  timestamp: Int!
}

type Margin @entity {
  id: ID!
  pool: Pool!
  poolAccount: PoolAccount!
  # account: Bytes!
  bTokenAddress: Bytes!
  bToken: String!
  pTokenId: BigInt!
  margin: BigInt!
  timestamp: Int!
}

type TradeHistory @entity {
  id: ID!
  pool: Pool!
  account: Bytes!
  symbol: String!
  symbolId: Bytes!
  pTokenId: BigInt!
  indexPrice: BigInt!
  tradeVolume: BigInt!
  tradeCost: BigInt!
  tradeFee: BigInt!
  timestamp: Int!
}

type Position @entity {
  id: ID!
  pool: Pool!
  poolAccount: PoolAccount!
  symbol: String!
  symbolId: Bytes!
  pTokenId: BigInt!
  volume: BigInt!
  timestamp: Int!
}

type Pool @entity {
  id: ID!
  admin: Bytes!
  implementation: Bytes!
  pToken: DToken!
  lToken: DToken!
  symbolManager: SymbolManager!
  swapper: Bytes!
  tokenB0: Bytes!
  tokenWETH: Bytes!
  marketB0: Bytes!
  marketWETH: Bytes!
  vaultImplementation: Bytes!
  protocolFeeCollector: Bytes!
  poolLiquidity: BigDecimal!
  liquidityHistory: [LiquidityHistory!]! @derivedFrom(field: "pool")
  tradeHistory: [TradeHistory!]! @derivedFrom(field: "pool")
  liquidity: [Liquidity!]! @derivedFrom(field: "pool")
  margin: [Margin!]! @derivedFrom(field: "pool")
  position: [Position!]! @derivedFrom(field: "pool")
}

type SymbolManager @entity {
  id: ID!
  pool: Pool!
}

type PoolAccount @entity {
  id: ID!
  account: Account!
  pool: Pool!
  pTokenId: BigInt!
  lTokenId: BigInt!
  positions: [Position!]! @derivedFrom(field: "poolAccount")
  liquidities: [Liquidity!]! @derivedFrom(field: "poolAccount")
  margins: [Margin!]! @derivedFrom(field: "poolAccount")
}

type Account @entity {
  id: ID!
  pools: [PoolAccount!]! @derivedFrom(field: "account")
}

