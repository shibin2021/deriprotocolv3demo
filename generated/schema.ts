// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class DToken extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DToken entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DToken must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DToken", id.toString(), this);
    }
  }

  static load(id: string): DToken | null {
    return changetype<DToken | null>(store.get("DToken", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get name(): string {
    let value = this.get("name");
    return value!.toString();
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get ownerTokenId(): Array<string> {
    let value = this.get("ownerTokenId");
    return value!.toStringArray();
  }

  set ownerTokenId(value: Array<string>) {
    this.set("ownerTokenId", Value.fromStringArray(value));
  }
}

export class OwnerTokenId extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OwnerTokenId entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type OwnerTokenId must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("OwnerTokenId", id.toString(), this);
    }
  }

  static load(id: string): OwnerTokenId | null {
    return changetype<OwnerTokenId | null>(store.get("OwnerTokenId", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value!.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get tokenId(): string {
    let value = this.get("tokenId");
    return value!.toString();
  }

  set tokenId(value: string) {
    this.set("tokenId", Value.fromString(value));
  }

  get token(): string {
    let value = this.get("token");
    return value!.toString();
  }

  set token(value: string) {
    this.set("token", Value.fromString(value));
  }

  get timestamp(): i32 {
    let value = this.get("timestamp");
    return value!.toI32();
  }

  set timestamp(value: i32) {
    this.set("timestamp", Value.fromI32(value));
  }
}

export class Vault extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Vault entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Vault must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Vault", id.toString(), this);
    }
  }

  static load(id: string): Vault | null {
    return changetype<Vault | null>(store.get("Vault", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get aavePool(): Bytes {
    let value = this.get("aavePool");
    return value!.toBytes();
  }

  set aavePool(value: Bytes) {
    this.set("aavePool", Value.fromBytes(value));
  }

  get aaveOracle(): Bytes {
    let value = this.get("aaveOracle");
    return value!.toBytes();
  }

  set aaveOracle(value: Bytes) {
    this.set("aaveOracle", Value.fromBytes(value));
  }
}

export class BToken extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save BToken entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type BToken must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("BToken", id.toString(), this);
    }
  }

  static load(id: string): BToken | null {
    return changetype<BToken | null>(store.get("BToken", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get bToken(): Bytes {
    let value = this.get("bToken");
    return value!.toBytes();
  }

  set bToken(value: Bytes) {
    this.set("bToken", Value.fromBytes(value));
  }

  get bTokenSymbol(): string {
    let value = this.get("bTokenSymbol");
    return value!.toString();
  }

  set bTokenSymbol(value: string) {
    this.set("bTokenSymbol", Value.fromString(value));
  }

  get bTokenDecimals(): i32 {
    let value = this.get("bTokenDecimals");
    return value!.toI32();
  }

  set bTokenDecimals(value: i32) {
    this.set("bTokenDecimals", Value.fromI32(value));
  }

  get market(): Bytes {
    let value = this.get("market");
    return value!.toBytes();
  }

  set market(value: Bytes) {
    this.set("market", Value.fromBytes(value));
  }

  get marketSymbol(): string {
    let value = this.get("marketSymbol");
    return value!.toString();
  }

  set marketSymbol(value: string) {
    this.set("marketSymbol", Value.fromString(value));
  }

  get marketDecimals(): i32 {
    let value = this.get("marketDecimals");
    return value!.toI32();
  }

  set marketDecimals(value: i32) {
    this.set("marketDecimals", Value.fromI32(value));
  }

  get bTokenPrice(): BigDecimal {
    let value = this.get("bTokenPrice");
    return value!.toBigDecimal();
  }

  set bTokenPrice(value: BigDecimal) {
    this.set("bTokenPrice", Value.fromBigDecimal(value));
  }

  get collateralFactor(): BigDecimal {
    let value = this.get("collateralFactor");
    return value!.toBigDecimal();
  }

  set collateralFactor(value: BigDecimal) {
    this.set("collateralFactor", Value.fromBigDecimal(value));
  }

  get pool(): string {
    let value = this.get("pool");
    return value!.toString();
  }

  set pool(value: string) {
    this.set("pool", Value.fromString(value));
  }
}

export class Symbol extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Symbol entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Symbol must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Symbol", id.toString(), this);
    }
  }

  static load(id: string): Symbol | null {
    return changetype<Symbol | null>(store.get("Symbol", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get category(): string {
    let value = this.get("category");
    return value!.toString();
  }

  set category(value: string) {
    this.set("category", Value.fromString(value));
  }

  get symbol(): string {
    let value = this.get("symbol");
    return value!.toString();
  }

  set symbol(value: string) {
    this.set("symbol", Value.fromString(value));
  }

  get symbolAddress(): Bytes {
    let value = this.get("symbolAddress");
    return value!.toBytes();
  }

  set symbolAddress(value: Bytes) {
    this.set("symbolAddress", Value.fromBytes(value));
  }

  get manager(): Bytes {
    let value = this.get("manager");
    return value!.toBytes();
  }

  set manager(value: Bytes) {
    this.set("manager", Value.fromBytes(value));
  }

  get oracleManager(): Bytes {
    let value = this.get("oracleManager");
    return value!.toBytes();
  }

  set oracleManager(value: Bytes) {
    this.set("oracleManager", Value.fromBytes(value));
  }

  get symbolId(): Bytes {
    let value = this.get("symbolId");
    return value!.toBytes();
  }

  set symbolId(value: Bytes) {
    this.set("symbolId", Value.fromBytes(value));
  }

  get feeRatio(): BigDecimal {
    let value = this.get("feeRatio");
    return value!.toBigDecimal();
  }

  set feeRatio(value: BigDecimal) {
    this.set("feeRatio", Value.fromBigDecimal(value));
  }

  get alpha(): BigDecimal {
    let value = this.get("alpha");
    return value!.toBigDecimal();
  }

  set alpha(value: BigDecimal) {
    this.set("alpha", Value.fromBigDecimal(value));
  }

  get fundingPeriod(): BigInt {
    let value = this.get("fundingPeriod");
    return value!.toBigInt();
  }

  set fundingPeriod(value: BigInt) {
    this.set("fundingPeriod", Value.fromBigInt(value));
  }

  get minTradeVolume(): BigDecimal {
    let value = this.get("minTradeVolume");
    return value!.toBigDecimal();
  }

  set minTradeVolume(value: BigDecimal) {
    this.set("minTradeVolume", Value.fromBigDecimal(value));
  }

  get minInitialMarginRatio(): BigDecimal {
    let value = this.get("minInitialMarginRatio");
    return value!.toBigDecimal();
  }

  set minInitialMarginRatio(value: BigDecimal) {
    this.set("minInitialMarginRatio", Value.fromBigDecimal(value));
  }

  get initialMarginRatio(): BigDecimal {
    let value = this.get("initialMarginRatio");
    return value!.toBigDecimal();
  }

  set initialMarginRatio(value: BigDecimal) {
    this.set("initialMarginRatio", Value.fromBigDecimal(value));
  }

  get maintenanceMarginRatio(): BigDecimal {
    let value = this.get("maintenanceMarginRatio");
    return value!.toBigDecimal();
  }

  set maintenanceMarginRatio(value: BigDecimal) {
    this.set("maintenanceMarginRatio", Value.fromBigDecimal(value));
  }

  get pricePercentThreshold(): BigDecimal {
    let value = this.get("pricePercentThreshold");
    return value!.toBigDecimal();
  }

  set pricePercentThreshold(value: BigDecimal) {
    this.set("pricePercentThreshold", Value.fromBigDecimal(value));
  }

  get timeThreshold(): BigInt {
    let value = this.get("timeThreshold");
    return value!.toBigInt();
  }

  set timeThreshold(value: BigInt) {
    this.set("timeThreshold", Value.fromBigInt(value));
  }

  get isCloseOnly(): boolean {
    let value = this.get("isCloseOnly");
    return value!.toBoolean();
  }

  set isCloseOnly(value: boolean) {
    this.set("isCloseOnly", Value.fromBoolean(value));
  }

  get priceId(): Bytes {
    let value = this.get("priceId");
    return value!.toBytes();
  }

  set priceId(value: Bytes) {
    this.set("priceId", Value.fromBytes(value));
  }

  get volatilityId(): Bytes {
    let value = this.get("volatilityId");
    return value!.toBytes();
  }

  set volatilityId(value: Bytes) {
    this.set("volatilityId", Value.fromBytes(value));
  }

  get feeRatioITM(): BigDecimal {
    let value = this.get("feeRatioITM");
    return value!.toBigDecimal();
  }

  set feeRatioITM(value: BigDecimal) {
    this.set("feeRatioITM", Value.fromBigDecimal(value));
  }

  get feeRatioOTM(): BigDecimal {
    let value = this.get("feeRatioOTM");
    return value!.toBigDecimal();
  }

  set feeRatioOTM(value: BigDecimal) {
    this.set("feeRatioOTM", Value.fromBigDecimal(value));
  }

  get strikePrice(): BigDecimal {
    let value = this.get("strikePrice");
    return value!.toBigDecimal();
  }

  set strikePrice(value: BigDecimal) {
    this.set("strikePrice", Value.fromBigDecimal(value));
  }

  get isCall(): boolean {
    let value = this.get("isCall");
    return value!.toBoolean();
  }

  set isCall(value: boolean) {
    this.set("isCall", Value.fromBoolean(value));
  }

  get netVolume(): BigDecimal {
    let value = this.get("netVolume");
    return value!.toBigDecimal();
  }

  set netVolume(value: BigDecimal) {
    this.set("netVolume", Value.fromBigDecimal(value));
  }

  get netCost(): BigDecimal {
    let value = this.get("netCost");
    return value!.toBigDecimal();
  }

  set netCost(value: BigDecimal) {
    this.set("netCost", Value.fromBigDecimal(value));
  }

  get indexPrice(): BigDecimal {
    let value = this.get("indexPrice");
    return value!.toBigDecimal();
  }

  set indexPrice(value: BigDecimal) {
    this.set("indexPrice", Value.fromBigDecimal(value));
  }

  get fundingTimestamp(): BigInt {
    let value = this.get("fundingTimestamp");
    return value!.toBigInt();
  }

  set fundingTimestamp(value: BigInt) {
    this.set("fundingTimestamp", Value.fromBigInt(value));
  }

  get cumulativeFundingPerVolume(): BigInt {
    let value = this.get("cumulativeFundingPerVolume");
    return value!.toBigInt();
  }

  set cumulativeFundingPerVolume(value: BigInt) {
    this.set("cumulativeFundingPerVolume", Value.fromBigInt(value));
  }

  get tradersPnl(): BigDecimal {
    let value = this.get("tradersPnl");
    return value!.toBigDecimal();
  }

  set tradersPnl(value: BigDecimal) {
    this.set("tradersPnl", Value.fromBigDecimal(value));
  }

  get initialMarginRequired(): BigDecimal {
    let value = this.get("initialMarginRequired");
    return value!.toBigDecimal();
  }

  set initialMarginRequired(value: BigDecimal) {
    this.set("initialMarginRequired", Value.fromBigDecimal(value));
  }

  get nPositionHolders(): BigInt {
    let value = this.get("nPositionHolders");
    return value!.toBigInt();
  }

  set nPositionHolders(value: BigInt) {
    this.set("nPositionHolders", Value.fromBigInt(value));
  }

  get pool(): string {
    let value = this.get("pool");
    return value!.toString();
  }

  set pool(value: string) {
    this.set("pool", Value.fromString(value));
  }
}

export class LiquidityHistory extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LiquidityHistory entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type LiquidityHistory must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("LiquidityHistory", id.toString(), this);
    }
  }

  static load(id: string): LiquidityHistory | null {
    return changetype<LiquidityHistory | null>(
      store.get("LiquidityHistory", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get pool(): string {
    let value = this.get("pool");
    return value!.toString();
  }

  set pool(value: string) {
    this.set("pool", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get action(): string {
    let value = this.get("action");
    return value!.toString();
  }

  set action(value: string) {
    this.set("action", Value.fromString(value));
  }

  get bToken(): Bytes {
    let value = this.get("bToken");
    return value!.toBytes();
  }

  set bToken(value: Bytes) {
    this.set("bToken", Value.fromBytes(value));
  }

  get bTokenSymbol(): string {
    let value = this.get("bTokenSymbol");
    return value!.toString();
  }

  set bTokenSymbol(value: string) {
    this.set("bTokenSymbol", Value.fromString(value));
  }

  get lTokenId(): BigInt {
    let value = this.get("lTokenId");
    return value!.toBigInt();
  }

  set lTokenId(value: BigInt) {
    this.set("lTokenId", Value.fromBigInt(value));
  }

  get amount(): BigDecimal {
    let value = this.get("amount");
    return value!.toBigDecimal();
  }

  set amount(value: BigDecimal) {
    this.set("amount", Value.fromBigDecimal(value));
  }

  get newLiquidity(): BigDecimal {
    let value = this.get("newLiquidity");
    return value!.toBigDecimal();
  }

  set newLiquidity(value: BigDecimal) {
    this.set("newLiquidity", Value.fromBigDecimal(value));
  }

  get timestamp(): i32 {
    let value = this.get("timestamp");
    return value!.toI32();
  }

  set timestamp(value: i32) {
    this.set("timestamp", Value.fromI32(value));
  }
}

export class Liquidity extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Liquidity entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Liquidity must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Liquidity", id.toString(), this);
    }
  }

  static load(id: string): Liquidity | null {
    return changetype<Liquidity | null>(store.get("Liquidity", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get pool(): string {
    let value = this.get("pool");
    return value!.toString();
  }

  set pool(value: string) {
    this.set("pool", Value.fromString(value));
  }

  get poolAccount(): string {
    let value = this.get("poolAccount");
    return value!.toString();
  }

  set poolAccount(value: string) {
    this.set("poolAccount", Value.fromString(value));
  }

  get bToken(): Bytes {
    let value = this.get("bToken");
    return value!.toBytes();
  }

  set bToken(value: Bytes) {
    this.set("bToken", Value.fromBytes(value));
  }

  get bTokenSymbol(): string {
    let value = this.get("bTokenSymbol");
    return value!.toString();
  }

  set bTokenSymbol(value: string) {
    this.set("bTokenSymbol", Value.fromString(value));
  }

  get lTokenId(): BigInt {
    let value = this.get("lTokenId");
    return value!.toBigInt();
  }

  set lTokenId(value: BigInt) {
    this.set("lTokenId", Value.fromBigInt(value));
  }

  get liquidity(): BigDecimal {
    let value = this.get("liquidity");
    return value!.toBigDecimal();
  }

  set liquidity(value: BigDecimal) {
    this.set("liquidity", Value.fromBigDecimal(value));
  }

  get timestamp(): i32 {
    let value = this.get("timestamp");
    return value!.toI32();
  }

  set timestamp(value: i32) {
    this.set("timestamp", Value.fromI32(value));
  }
}

export class MarginHistory extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save MarginHistory entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type MarginHistory must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("MarginHistory", id.toString(), this);
    }
  }

  static load(id: string): MarginHistory | null {
    return changetype<MarginHistory | null>(store.get("MarginHistory", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get pool(): string {
    let value = this.get("pool");
    return value!.toString();
  }

  set pool(value: string) {
    this.set("pool", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get action(): string {
    let value = this.get("action");
    return value!.toString();
  }

  set action(value: string) {
    this.set("action", Value.fromString(value));
  }

  get bToken(): Bytes {
    let value = this.get("bToken");
    return value!.toBytes();
  }

  set bToken(value: Bytes) {
    this.set("bToken", Value.fromBytes(value));
  }

  get bTokenSymbol(): string {
    let value = this.get("bTokenSymbol");
    return value!.toString();
  }

  set bTokenSymbol(value: string) {
    this.set("bTokenSymbol", Value.fromString(value));
  }

  get pTokenId(): BigInt {
    let value = this.get("pTokenId");
    return value!.toBigInt();
  }

  set pTokenId(value: BigInt) {
    this.set("pTokenId", Value.fromBigInt(value));
  }

  get amount(): BigDecimal {
    let value = this.get("amount");
    return value!.toBigDecimal();
  }

  set amount(value: BigDecimal) {
    this.set("amount", Value.fromBigDecimal(value));
  }

  get newMargin(): BigDecimal {
    let value = this.get("newMargin");
    return value!.toBigDecimal();
  }

  set newMargin(value: BigDecimal) {
    this.set("newMargin", Value.fromBigDecimal(value));
  }

  get timestamp(): i32 {
    let value = this.get("timestamp");
    return value!.toI32();
  }

  set timestamp(value: i32) {
    this.set("timestamp", Value.fromI32(value));
  }
}

export class Margin extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Margin entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Margin must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Margin", id.toString(), this);
    }
  }

  static load(id: string): Margin | null {
    return changetype<Margin | null>(store.get("Margin", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get pool(): string {
    let value = this.get("pool");
    return value!.toString();
  }

  set pool(value: string) {
    this.set("pool", Value.fromString(value));
  }

  get poolAccount(): string {
    let value = this.get("poolAccount");
    return value!.toString();
  }

  set poolAccount(value: string) {
    this.set("poolAccount", Value.fromString(value));
  }

  get bToken(): Bytes {
    let value = this.get("bToken");
    return value!.toBytes();
  }

  set bToken(value: Bytes) {
    this.set("bToken", Value.fromBytes(value));
  }

  get bTokenSymbol(): string {
    let value = this.get("bTokenSymbol");
    return value!.toString();
  }

  set bTokenSymbol(value: string) {
    this.set("bTokenSymbol", Value.fromString(value));
  }

  get pTokenId(): BigInt {
    let value = this.get("pTokenId");
    return value!.toBigInt();
  }

  set pTokenId(value: BigInt) {
    this.set("pTokenId", Value.fromBigInt(value));
  }

  get margin(): BigDecimal {
    let value = this.get("margin");
    return value!.toBigDecimal();
  }

  set margin(value: BigDecimal) {
    this.set("margin", Value.fromBigDecimal(value));
  }

  get timestamp(): i32 {
    let value = this.get("timestamp");
    return value!.toI32();
  }

  set timestamp(value: i32) {
    this.set("timestamp", Value.fromI32(value));
  }
}

export class TradeHistory extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TradeHistory entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TradeHistory must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("TradeHistory", id.toString(), this);
    }
  }

  static load(id: string): TradeHistory | null {
    return changetype<TradeHistory | null>(store.get("TradeHistory", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get pool(): string {
    let value = this.get("pool");
    return value!.toString();
  }

  set pool(value: string) {
    this.set("pool", Value.fromString(value));
  }

  get action(): string {
    let value = this.get("action");
    return value!.toString();
  }

  set action(value: string) {
    this.set("action", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get symbol(): string {
    let value = this.get("symbol");
    return value!.toString();
  }

  set symbol(value: string) {
    this.set("symbol", Value.fromString(value));
  }

  get symbolId(): Bytes {
    let value = this.get("symbolId");
    return value!.toBytes();
  }

  set symbolId(value: Bytes) {
    this.set("symbolId", Value.fromBytes(value));
  }

  get pTokenId(): BigInt {
    let value = this.get("pTokenId");
    return value!.toBigInt();
  }

  set pTokenId(value: BigInt) {
    this.set("pTokenId", Value.fromBigInt(value));
  }

  get indexPrice(): BigDecimal {
    let value = this.get("indexPrice");
    return value!.toBigDecimal();
  }

  set indexPrice(value: BigDecimal) {
    this.set("indexPrice", Value.fromBigDecimal(value));
  }

  get tradeVolume(): BigDecimal {
    let value = this.get("tradeVolume");
    return value!.toBigDecimal();
  }

  set tradeVolume(value: BigDecimal) {
    this.set("tradeVolume", Value.fromBigDecimal(value));
  }

  get tradeCost(): BigDecimal {
    let value = this.get("tradeCost");
    return value!.toBigDecimal();
  }

  set tradeCost(value: BigDecimal) {
    this.set("tradeCost", Value.fromBigDecimal(value));
  }

  get tradeFee(): BigDecimal {
    let value = this.get("tradeFee");
    return value!.toBigDecimal();
  }

  set tradeFee(value: BigDecimal) {
    this.set("tradeFee", Value.fromBigDecimal(value));
  }

  get timestamp(): i32 {
    let value = this.get("timestamp");
    return value!.toI32();
  }

  set timestamp(value: i32) {
    this.set("timestamp", Value.fromI32(value));
  }
}

export class Position extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Position entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Position must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Position", id.toString(), this);
    }
  }

  static load(id: string): Position | null {
    return changetype<Position | null>(store.get("Position", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get pool(): string {
    let value = this.get("pool");
    return value!.toString();
  }

  set pool(value: string) {
    this.set("pool", Value.fromString(value));
  }

  get poolAccount(): string {
    let value = this.get("poolAccount");
    return value!.toString();
  }

  set poolAccount(value: string) {
    this.set("poolAccount", Value.fromString(value));
  }

  get symbol(): string {
    let value = this.get("symbol");
    return value!.toString();
  }

  set symbol(value: string) {
    this.set("symbol", Value.fromString(value));
  }

  get symbolId(): Bytes {
    let value = this.get("symbolId");
    return value!.toBytes();
  }

  set symbolId(value: Bytes) {
    this.set("symbolId", Value.fromBytes(value));
  }

  get pTokenId(): BigInt {
    let value = this.get("pTokenId");
    return value!.toBigInt();
  }

  set pTokenId(value: BigInt) {
    this.set("pTokenId", Value.fromBigInt(value));
  }

  get volume(): BigDecimal {
    let value = this.get("volume");
    return value!.toBigDecimal();
  }

  set volume(value: BigDecimal) {
    this.set("volume", Value.fromBigDecimal(value));
  }

  get timestamp(): i32 {
    let value = this.get("timestamp");
    return value!.toI32();
  }

  set timestamp(value: i32) {
    this.set("timestamp", Value.fromI32(value));
  }
}

export class Pool extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Pool entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Pool must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Pool", id.toString(), this);
    }
  }

  static load(id: string): Pool | null {
    return changetype<Pool | null>(store.get("Pool", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get admin(): Bytes {
    let value = this.get("admin");
    return value!.toBytes();
  }

  set admin(value: Bytes) {
    this.set("admin", Value.fromBytes(value));
  }

  get implementation(): Bytes {
    let value = this.get("implementation");
    return value!.toBytes();
  }

  set implementation(value: Bytes) {
    this.set("implementation", Value.fromBytes(value));
  }

  get pToken(): string {
    let value = this.get("pToken");
    return value!.toString();
  }

  set pToken(value: string) {
    this.set("pToken", Value.fromString(value));
  }

  get lToken(): string {
    let value = this.get("lToken");
    return value!.toString();
  }

  set lToken(value: string) {
    this.set("lToken", Value.fromString(value));
  }

  get symbolManager(): string {
    let value = this.get("symbolManager");
    return value!.toString();
  }

  set symbolManager(value: string) {
    this.set("symbolManager", Value.fromString(value));
  }

  get swapper(): Bytes {
    let value = this.get("swapper");
    return value!.toBytes();
  }

  set swapper(value: Bytes) {
    this.set("swapper", Value.fromBytes(value));
  }

  get tokenB0(): Bytes {
    let value = this.get("tokenB0");
    return value!.toBytes();
  }

  set tokenB0(value: Bytes) {
    this.set("tokenB0", Value.fromBytes(value));
  }

  get tokenWETH(): Bytes {
    let value = this.get("tokenWETH");
    return value!.toBytes();
  }

  set tokenWETH(value: Bytes) {
    this.set("tokenWETH", Value.fromBytes(value));
  }

  get marketB0(): Bytes {
    let value = this.get("marketB0");
    return value!.toBytes();
  }

  set marketB0(value: Bytes) {
    this.set("marketB0", Value.fromBytes(value));
  }

  get marketWETH(): Bytes {
    let value = this.get("marketWETH");
    return value!.toBytes();
  }

  set marketWETH(value: Bytes) {
    this.set("marketWETH", Value.fromBytes(value));
  }

  get vaultImplementation(): Bytes {
    let value = this.get("vaultImplementation");
    return value!.toBytes();
  }

  set vaultImplementation(value: Bytes) {
    this.set("vaultImplementation", Value.fromBytes(value));
  }

  get protocolFeeCollector(): Bytes {
    let value = this.get("protocolFeeCollector");
    return value!.toBytes();
  }

  set protocolFeeCollector(value: Bytes) {
    this.set("protocolFeeCollector", Value.fromBytes(value));
  }

  get bTokens(): Array<string> {
    let value = this.get("bTokens");
    return value!.toStringArray();
  }

  set bTokens(value: Array<string>) {
    this.set("bTokens", Value.fromStringArray(value));
  }

  get poolLiquidity(): BigDecimal {
    let value = this.get("poolLiquidity");
    return value!.toBigDecimal();
  }

  set poolLiquidity(value: BigDecimal) {
    this.set("poolLiquidity", Value.fromBigDecimal(value));
  }

  get margin(): Array<string> {
    let value = this.get("margin");
    return value!.toStringArray();
  }

  set margin(value: Array<string>) {
    this.set("margin", Value.fromStringArray(value));
  }

  get position(): Array<string> {
    let value = this.get("position");
    return value!.toStringArray();
  }

  set position(value: Array<string>) {
    this.set("position", Value.fromStringArray(value));
  }

  get liquidity(): Array<string> {
    let value = this.get("liquidity");
    return value!.toStringArray();
  }

  set liquidity(value: Array<string>) {
    this.set("liquidity", Value.fromStringArray(value));
  }

  get liquidityHistory(): Array<string> {
    let value = this.get("liquidityHistory");
    return value!.toStringArray();
  }

  set liquidityHistory(value: Array<string>) {
    this.set("liquidityHistory", Value.fromStringArray(value));
  }

  get marginHistory(): Array<string> {
    let value = this.get("marginHistory");
    return value!.toStringArray();
  }

  set marginHistory(value: Array<string>) {
    this.set("marginHistory", Value.fromStringArray(value));
  }

  get tradeHistory(): Array<string> {
    let value = this.get("tradeHistory");
    return value!.toStringArray();
  }

  set tradeHistory(value: Array<string>) {
    this.set("tradeHistory", Value.fromStringArray(value));
  }
}

export class SymbolManager extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SymbolManager entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SymbolManager must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SymbolManager", id.toString(), this);
    }
  }

  static load(id: string): SymbolManager | null {
    return changetype<SymbolManager | null>(store.get("SymbolManager", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get pool(): string {
    let value = this.get("pool");
    return value!.toString();
  }

  set pool(value: string) {
    this.set("pool", Value.fromString(value));
  }

  get length(): BigInt {
    let value = this.get("length");
    return value!.toBigInt();
  }

  set length(value: BigInt) {
    this.set("length", Value.fromBigInt(value));
  }
}

export class PoolAccount extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PoolAccount entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PoolAccount must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PoolAccount", id.toString(), this);
    }
  }

  static load(id: string): PoolAccount | null {
    return changetype<PoolAccount | null>(store.get("PoolAccount", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): string {
    let value = this.get("account");
    return value!.toString();
  }

  set account(value: string) {
    this.set("account", Value.fromString(value));
  }

  get pool(): string {
    let value = this.get("pool");
    return value!.toString();
  }

  set pool(value: string) {
    this.set("pool", Value.fromString(value));
  }

  get lTokenId(): BigInt {
    let value = this.get("lTokenId");
    return value!.toBigInt();
  }

  set lTokenId(value: BigInt) {
    this.set("lTokenId", Value.fromBigInt(value));
  }

  get liquidities(): Array<string> {
    let value = this.get("liquidities");
    return value!.toStringArray();
  }

  set liquidities(value: Array<string>) {
    this.set("liquidities", Value.fromStringArray(value));
  }

  get pTokenId(): BigInt {
    let value = this.get("pTokenId");
    return value!.toBigInt();
  }

  set pTokenId(value: BigInt) {
    this.set("pTokenId", Value.fromBigInt(value));
  }

  get margins(): Array<string> {
    let value = this.get("margins");
    return value!.toStringArray();
  }

  set margins(value: Array<string>) {
    this.set("margins", Value.fromStringArray(value));
  }

  get positions(): Array<string> {
    let value = this.get("positions");
    return value!.toStringArray();
  }

  set positions(value: Array<string>) {
    this.set("positions", Value.fromStringArray(value));
  }
}

export class Account extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Account entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Account must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Account", id.toString(), this);
    }
  }

  static load(id: string): Account | null {
    return changetype<Account | null>(store.get("Account", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get pools(): Array<string> {
    let value = this.get("pools");
    return value!.toStringArray();
  }

  set pools(value: Array<string>) {
    this.set("pools", Value.fromStringArray(value));
  }
}
